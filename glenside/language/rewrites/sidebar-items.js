initSidebarItems({"enum":[["PadLocation",""],["PadSliceStrategy",""],["SliceConcatenateStrategy",""]],"fn":[["access_slice_access_transpose_composition_commutative",""],["bubble_access_concatenate_through_access",""],["bubble_access_concatenate_through_access_cartesian_product_not_item_axis_left",""],["bubble_access_concatenate_through_access_cartesian_product_not_item_axis_right",""],["bubble_access_concatenate_through_access_cartesian_product_same_item_axis",""],["bubble_access_concatenate_through_access_slice",""],["bubble_access_concatenate_through_access_transpose",""],["bubble_access_concatenate_through_compute_dot_product_item_axis",""],["bubble_access_concatenate_through_compute_dot_product_not_item_axis","When bubbling up through (compute dot-product …), what you do depends on whether you’re concatenating along an item axis or not. If you are not, it’s easy: you just bubble it straight through. If you are, then you are concatenating along an axis that’s getting reduced in the reduction sum. So we need to explicitly insert another reduction."],["bubble_access_slice_through_access_cartesian_product_not_item_axis_left",""],["bubble_access_slice_through_access_cartesian_product_not_item_axis_right",""],["bubble_access_slice_through_access_cartesian_product_same_item_axis",""],["bubble_access_slice_through_access_pad_inequal_axes",""],["bubble_access_slice_through_compute_dot_product_item_axis_not_tuple_axis","If we’re slicing in an item axis that isn’t the tuple axis (i.e. the first item axis), then computing before slicing has the potential to affect the computation, as it is adding data. So we need to be able to prove that this region will not affect the computation."],["bubble_access_slice_through_compute_dot_product_not_item_axis","If we’re not slicing in an axis that’s being computed over, then removing the slice has no potential to effect the computation. It will just result in a larger computation, with some of the data being sliced away."],["bubble_access_transpose_through_access_pad",""],["bubble_concatenate_through_cartesian_product_axis_0_0",""],["bubble_concatenate_through_cartesian_product_last_axis",""],["bubble_concatenate_through_cartesian_product_not_last_axis_left",""],["bubble_concatenate_through_cartesian_product_not_last_axis_right",""],["bubble_concatenate_through_map_dot_product_last_axis",""],["bubble_concatenate_through_map_dot_product_not_last_axis",""],["bubble_concatenate_through_move_axis",""],["bubble_reshape_through_cartesian_product",""],["bubble_reshape_through_compute_dot_product",""],["collapse_nested_access_slices",""],["collapse_nested_accesses",""],["collapse_nested_slices",""],["collapse_nested_transposes",""],["flatten_unflatten_any_access",""],["has_shape",""],["is_symbol","short_circuit lets us return early if we don’t actually care about the result of this check. This is the easiest way I could find to do this using egg’s conditional appliers. TODO(@gussmith23) make this cleaner"],["pad_slice_accesses",""],["remove_trivial_transpose",""],["rewrite_nonmatching_cartesian_product_concatenate",""],["slice_concatenate_accesses",""],["slice_concatenate_tensor_accesses",""],["slice_move_axis_composition_commutative",""],["split",""],["systolic_array",""],["systolic_array_conv2d_im2col_fc_with_blocking","TODO(@gussmith23) This is a hack This is pretty hyper-specific to how we currently implement conv2d when reading from Relay. That is, to implement conv2d, we transpose to NCHW"],["systolic_array_conv2d_im2col_nchw_oihw_with_blocking",""],["systolic_array_conv2d_im2col_nhwc_hwio_with_blocking",""],["systolic_array_conv2d_nchw_oihw_with_blocking",""],["systolic_array_conv2d_nhwc_hwio_with_blocking",""],["systolic_array_vector_matrix",""],["systolic_array_with_blocking","Tensorizes a computation to an externally-blocked systolic array."]],"struct":[["RewriteNonMatchingCartConcatenateApplier",""]]});